?as_tibble
load_all()
test_that("bin_pair column exists", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
bp_vec <- mutate_basis_matrix(test_fit) %>%
pull(bin_pair)
expect_true(is.character(bp_vec))
})
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
any(str_detect(check_cols, "celltype[0-9]*_features"))
})
test_that("std deviation works with more than two cell types", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
sd_vec <- mutate_basis_matrix(test_fit) %>%
pull(std_dev)
expect_true(is.numeric(sd_vec))
expect_true(all(sd_vec > 0))
})
test_that("feature score works with more than two cell types", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
fs_vec <- mutate_basis_matrix(test_fit) %>%
pull(feature_score)
expect_true(is.numeric(fs_vec))
})
test_that("bin_pair column exists", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
bp_vec <- mutate_basis_matrix(test_fit) %>%
pull(bin_pair)
expect_true(is.character(bp_vec))
})
mutate_basis_matrix(test_fit)
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
all(str_detect(check_cols, "celltype[0-9]*_features"))
})
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
check_cols
mutate_basis_matrix(test_fit)
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
all(str_detect(check_cols, "celltype[0-9]*_features"))
})
all(str_detect(check_cols, "celltype[0-9]*_features"))
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
all(str_detect(check_cols, "celltype[0-9]*_features"))
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(1:k))
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1)))
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
#Generate some random number of cell types
k <- sample(1:100, size = 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1)))
#Generate some random number of cell types
k <- 5
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1)))
check_cols
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
all(str_detect(check_cols, "celltype[0-9]*_features"))
check_cols
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- 5
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(1:100, 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
k
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(2:10, 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
test_that("std deviation works with more than two cell types", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
sd_vec <- mutate_basis_matrix(test_fit) %>%
pull(std_dev)
expect_true(is.numeric(sd_vec))
expect_true(all(sd_vec > 0))
})
test_that("feature score works with more than two cell types", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
fs_vec <- mutate_basis_matrix(test_fit) %>%
pull(feature_score)
expect_true(is.numeric(fs_vec))
})
test_that("bin_pair column exists", {
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
bp_vec <- mutate_basis_matrix(test_fit) %>%
pull(bin_pair)
expect_true(is.character(bp_vec))
})
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = 5,
itter = 1)
mutate_basis_matrix(test_fit)
check()
load_all()
test_that("colnames are formatted correctly", {
#Generate some random number of cell types
k <- sample(2:10, 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
expect_true(all(str_detect(check_cols, "celltype[0-9]*_features")))
})
k <- sample(2:10, 1)
test_fit <- thunder("example_data/test_data.txt.gz", n_cell_types = k,
itter = 1)
#We want to check that the first k columns are formatted as we expect.
check_cols <- mutate_basis_matrix(test_fit) %>%
select(all_of(2:(k+1))) %>%
colnames()
check_cols
check()
check()
load_all()
load_all()
check()
check()
test_check("thunder")
test_file("tests/testthat/test-thunder.R")
test_file("tests/testthat/test-thunder.R")
test_file("tests/testthat/test-mutate_basis_matrix.R")
check()
check()
check()
suppressWarnings(readLines("http://worldclockapi.com/api/json/utc/now",
warn = FALSE))
check()
check()
load_all()
thunder("test_data.txt.gz", n_cell_types = 2,
itter = 1,
out_init_nmf = "test_data_init_out.rds")
test_file("tests/testthat/test-thunder.R")
load_all()
thunder("test_data.txt.gz", n_cell_types = 5,
itter = 1)
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1)
load_all()
check()
check()
check()
check()
document()
document()
thunder("test_data.txt.gz", n_cell_types = 5,
itter = 1)
thunder("tests/test_data.txt.gz", n_cell_types = 5,
itter = 1)
load_all()
library(devtools)
thunder("tests/test_data.txt.gz", n_cell_types = 5,
itter = 1)
load_all()
thunder("tests/test_data.txt.gz", n_cell_types = 5,
itter = 1)
getwd()
thunder("tests/test_data.txt.gz", n_cell_types = 5,
itter = 1)
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1)
#'@importFrom dplyr filter
#'@importFrom dplyr %>%
#'
#' @param path_to_mixture String. Path to .tsv file of bulk Hi-C samples.
#' @param n_cell_types Integer. The number of columns in the basis matrix of the deconvolution. Corresponds to the number of cell types in bulk Hi-C mixture.
#' @param itter Integer. Number of itterations for NMF algorithm. Default is 200.
#' @param out_init_nmf String. Default is NULL. If character, then saves the initial NMF fit as a .RDS object to specified file path.
#'
#' @export
#'
thunder <- function(path_to_mixture, n_cell_types, itter=200,
out_init_nmf = NULL){
.mix <- read_tsv(path_to_mixture) %>%
column_to_rownames("bin_name") %>%
filter(rowSums(.) != 0)
.fit_init <- initial_nmf_fit(mixture = .mix,
n_cell_types = n_cell_types,
itter = itter)
if ( is.character(out_init_nmf) ){
print("Saving initial NMF fit . . .")
saveRDS(object = .fit_init, file = out_init_nmf)
}
return(.fit_init)
}
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1)
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1) %>% mutate_basis_matrix()
subset_init_nmf <- function(nmf_obj){
.basis_m <- mutate_basis_matrix(nmf_obj)
return(.basis_m)
}
#'@importFrom dplyr filter
#'@importFrom dplyr %>%
#'
#' @param path_to_mixture String. Path to .tsv file of bulk Hi-C samples.
#' @param n_cell_types Integer. The number of columns in the basis matrix of the deconvolution. Corresponds to the number of cell types in bulk Hi-C mixture.
#' @param itter Integer. Number of itterations for NMF algorithm. Default is 200.
#' @param out_init_nmf String. Default is NULL. If character, then saves the initial NMF fit as a .RDS object to specified file path.
#'
#' @export
#'
thunder <- function(path_to_mixture, n_cell_types, itter=200,
out_init_nmf = NULL){
.mix <- read_tsv(path_to_mixture) %>%
column_to_rownames("bin_name") %>%
filter(rowSums(.) != 0)
.fit_init <- initial_nmf_fit(mixture = .mix,
n_cell_types = n_cell_types,
itter = itter)
if ( is.character(out_init_nmf) ){
print("Saving initial NMF fit . . .")
saveRDS(object = .fit_init, file = out_init_nmf)
}
return(.fit_init)
}
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1) %>% subset_init_nmf()
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1) %>% basis()
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1) %>% basis() %>% dim()
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1)
init <- thunder("tests/testthat/test_data.txt.gz", n_cell_types = 5,
itter = 1)
init
load_all()
subset_init_nmf("tests/testthat/test_data.txt.gz", init)
rm(thunder)
rm(subset_init_nmf())
rm(subset_init_nmf
)
load_all()
subset_init_nmf("tests/testthat/test_data.txt.gz", init)
path <- "tests/testthat/test_data.txt.gz"
read_tsv(path) %>%
column_to_rownames("bin_name") %>%
filter(rowSums(.) != 0)
mix <- read_tsv(path) %>%
column_to_rownames("bin_name") %>%
filter(rowSums(.) != 0)
subset_init_nmf(mix, init)
dim(mix)
mix
which(init$feature_score > 1)
subset_init_nmf <- function(mixture_data, nmf_obj){
.basis_m <- mutate_basis_matrix(nmf_obj)
return(.basis_m)
}
init$feature_score
init
rm(subset_init_nmf())
rm(subset_init_nmf
)
subset_init_nmf(mix, init)
t <- subset_init_nmf(mix, init)
t$feature_score
t
t$bin_pair %>% head()
t$bin_pair[[1]]
str_split(t$bin_pair[[1]], "_")
library(stringr)
str_split(t$bin_pair[[1]], "_")
str_split(t$bin_pair[[1]], "_")[[1]]
str_split(t$bin_pair[[1]], "_")[[1]][2] == str_split(t$bin_pair[[1]], "_")[[1]][5]
t
.basis  %>%
as_tibble(rownames = "bin_pair") %>%
rowwise() %>%
mutate(std_dev = sd(c_across(starts_with("celltype")))) %>%
ungroup() %>%
mutate(feature_score = featureScore(nmf_obj),
contact_type == if_else(
str_split(bin_pair[[1]], "_")[[1]][2] == str_split(bin_pair[[1]], "_")[[1]][5],
"intra", "inter"
)) %>%
return()
load_all
load_all()
init
mutate_basis_matrix(init)
load_all()
mutate_basis_matrix(init)
load_all()
mutate_basis_matrix(init)
?if_else
document()
load_all()
mutate_basis_matrix(init)
t <- mutate_basis_matrix(init)
t
t %>%
group_by(contact_type)
library(tidyverse)
t %>%
group_by(contact_type)
))
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$stdev > mean(.$stdev) + 3*sd(.$stdev))
)))
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$stdev > mean(.$std_dev) + 3*sd(.$std_dev))
)))
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
)))
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
))) %>%
unnest(thunder_bins)
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
))) %>%
unnest(thunder_bins) %>%
pull(thunder_bins)
rows <- t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
))) %>%
unnest(thunder_bins) %>%
pull(thunder_bins)
mix
mix[rows, ]
rows
t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
))) %>%
unnest(thunder_bins) %>%
ungroup() %>%
arrange(thunder_bins)%>%
pull(thunder_bins)
rows <- t %>%
group_by(contact_type) %>%
summarise(thunder_bins = list(which(
(.$feature_score > mean(.$feature_score) + 3*sd(.$feature_score)) |
(.$std_dev > mean(.$std_dev) + 3*sd(.$std_dev))
))) %>%
unnest(thunder_bins) %>%
ungroup() %>%
arrange(thunder_bins)%>%
pull(thunder_bins)
mix[rows, ]
subset_init_nmf(mix, init)
load_all()
subset_init_nmf(mix, init)
document()
load_all()
load_all()
#'@importFrom dplyr filter
#'@importFrom dplyr %>%
#'
#' @param path_to_mixture String. Path to .tsv file of bulk Hi-C samples.
#' @param n_cell_types Integer. The number of columns in the basis matrix of the deconvolution. Corresponds to the number of cell types in bulk Hi-C mixture.
#' @param itter Integer. Number of itterations for NMF algorithm. Default is 200.
#' @param out_init_nmf String. Default is NULL. If character, then saves the initial NMF fit as a .RDS object to specified file path.
#'
#' @export
#'
thunder <- function(path_to_mixture, n_cell_types, itter=200,
out_init_nmf = NULL){
.mix <- read_tsv(path_to_mixture) %>%
column_to_rownames("bin_name") %>%
filter(rowSums(.) != 0)
.fit_init <- nmf_fit(mixture = .mix,
n_cell_types = n_cell_types,
itter = itter)
if ( is.character(out_init_nmf) ){
print("Saving initial NMF fit . . .")
saveRDS(object = .fit_init, file = out_init_nmf)
}
.subset_mix <- subset_init_nmf(.mix, .fit_init)
.subset_fit <- nmf_fit(mixture = .subset_mix,
n_cell_types = n_cell_types,
itter = itter)
return(.subset_fit)
}
thunder("tests/testthat/test_data.txt.gz", )
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 3, itter = 2)
library(NMF)
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 3, itter = 2)
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 3, itter = 2) %>% basis()
get_props <- function(thunder_fit){
thunder_fit %>%
coef()  %>%
sweep(2, colSums(.), "/") %>%
t()
}
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 3, itter = 2) %>% get_props()
thunder("tests/testthat/test_data.txt.gz", n_cell_types = 2, itter = 2) %>% get_props()
?sweep
document()
document()
document()
load_all()
rm(get_props)
load_all()
?get_props
